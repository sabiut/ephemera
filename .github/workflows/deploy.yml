name: Deploy Ephemera to GKE

on:
  push:
    branches:
      - main
    paths:
      - 'api/**'
      - 'Dockerfile'
      - 'docker-compose.yml'
      - '.github/workflows/deploy.yml'
      - 'infrastructure/k8s/ephemera/**'
      - 'infrastructure/terraform/gcp/**'

  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - destroy

env:
  GCP_PROJECT_ID: ephemera-dev-2025
  GKE_CLUSTER: ephemera-dev
  GKE_REGION: us-central1
  ARTIFACT_REGISTRY: us-central1-docker.pkg.dev/ephemera-dev-2025/ephemera

jobs:
  # ──────────────────────────────────────────────
  # DESTROY JOB — tears down all GCP infrastructure
  # ──────────────────────────────────────────────
  destroy:
    name: Destroy Infrastructure
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
      with:
        install_components: 'gke-gcloud-auth-plugin'

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_wrapper: false

    - name: Terraform Init
      run: |
        cd infrastructure/terraform/gcp
        terraform init -input=false

    - name: Migrate Terraform state (remove secrets module)
      run: |
        cd infrastructure/terraform/gcp
        terraform state rm module.kubernetes_secrets 2>/dev/null || true

    - name: Terraform Destroy
      run: |
        cd infrastructure/terraform/gcp
        terraform destroy -auto-approve \
          -var="gcp_project_id=${{ env.GCP_PROJECT_ID }}" \
          -var="gcp_region=${{ env.GKE_REGION }}" \
          -var="environment=dev" \
          -var="owner=sabiut" \
          -var="cluster_version=1.34"

    - name: Confirm destruction
      run: |
        echo "All GCP infrastructure has been destroyed."
        echo "To redeploy, trigger this workflow with action=deploy"

  # ──────────────────────────────────────────────
  # DEPLOY JOB — provisions infra + deploys app
  # ──────────────────────────────────────────────
  deploy:
    name: Deploy Infrastructure & Application
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'deploy')
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
      with:
        install_components: 'gke-gcloud-auth-plugin'

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_wrapper: false

    # ─── Terraform: Provision Infrastructure ─────
    - name: Terraform Init
      run: |
        cd infrastructure/terraform/gcp
        terraform init -input=false

    - name: Migrate Terraform state (remove secrets module)
      run: |
        cd infrastructure/terraform/gcp
        # One-time migration: remove kubernetes_secrets module from state
        # so Terraform doesn't try to destroy the K8s secret (now managed by kubectl)
        terraform state rm module.kubernetes_secrets 2>/dev/null || true

    - name: Terraform Apply
      run: |
        cd infrastructure/terraform/gcp
        terraform apply -auto-approve \
          -var="gcp_project_id=${{ env.GCP_PROJECT_ID }}" \
          -var="gcp_region=${{ env.GKE_REGION }}" \
          -var="environment=dev" \
          -var="owner=sabiut" \
          -var="cluster_version=1.34"

    # ─── Connect to GKE ─────────────────────────
    - name: Get GKE credentials
      run: |
        gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
          --region ${{ env.GKE_REGION }} \
          --project ${{ env.GCP_PROJECT_ID }}
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: "True"

    # ─── Build & Push Docker Images ──────────────
    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker us-central1-docker.pkg.dev

    - name: Build and push API image
      run: |
        docker build -f api/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/ephemera-api:${{ github.sha }} -t ${{ env.ARTIFACT_REGISTRY }}/ephemera-api:latest ./api
        docker push ${{ env.ARTIFACT_REGISTRY }}/ephemera-api:${{ github.sha }}
        docker push ${{ env.ARTIFACT_REGISTRY }}/ephemera-api:latest

    - name: Build and push Celery Worker image
      run: |
        docker build -f api/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-worker:${{ github.sha }} -t ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-worker:latest ./api
        docker push ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-worker:${{ github.sha }}
        docker push ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-worker:latest

    - name: Build and push Celery Beat image
      run: |
        docker build -f api/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-beat:${{ github.sha }} -t ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-beat:latest ./api
        docker push ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-beat:${{ github.sha }}
        docker push ${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-beat:latest

    # ─── Get Terraform Outputs ───────────────────
    - name: Get infrastructure connection strings from Terraform
      run: |
        cd infrastructure/terraform/gcp

        # Get Redis connection info
        REDIS_HOST=$(terraform output -raw redis_host 2>/dev/null || echo "")
        REDIS_PORT=$(terraform output -raw redis_port 2>/dev/null || echo "")
        REDIS_AUTH=$(terraform output -raw redis_auth_string 2>/dev/null || echo "")

        # Construct Redis URL with authentication and TLS
        REDIS_URL="rediss://:${REDIS_AUTH}@${REDIS_HOST}:${REDIS_PORT}/0"

        # Get PostgreSQL connection info
        DB_HOST=$(terraform output -raw cloudsql_private_ip 2>/dev/null || echo "")
        DB_NAME=$(terraform output -raw cloudsql_database_name 2>/dev/null || echo "")
        DB_USER=$(terraform output -raw cloudsql_username 2>/dev/null || echo "")
        DB_PASSWORD_RAW=$(gcloud secrets versions access latest --secret="ephemera-dev-db-password" --project="${{ env.GCP_PROJECT_ID }}" 2>/dev/null || echo "")

        # URL-encode the password to handle special characters
        DB_PASSWORD=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${DB_PASSWORD_RAW}', safe=''))")

        DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}"

        # Export to GitHub environment
        {
          echo "REDIS_URL<<EOF"
          echo "${REDIS_URL}"
          echo "EOF"
          echo "DATABASE_URL<<EOF"
          echo "${DATABASE_URL}"
          echo "EOF"
        } >> $GITHUB_ENV

    - name: Get static IP from Terraform
      run: |
        cd infrastructure/terraform/gcp
        STATIC_IP=$(terraform output -raw ingress_ip 2>/dev/null || echo "")
        echo "STATIC_IP=${STATIC_IP}" >> $GITHUB_ENV

    # ─── Install Cluster Components ──────────────
    - name: Install nginx-ingress controller
      run: |
        if ! kubectl get namespace ingress-nginx &> /dev/null; then
          echo "Installing nginx-ingress controller with static IP: ${{ env.STATIC_IP }}"
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml

          # Configure LoadBalancer to use static IP
          kubectl patch service ingress-nginx-controller -n ingress-nginx \
            -p '{"spec":{"loadBalancerIP":"${{ env.STATIC_IP }}"}}'

          # Wait for ingress controller to be ready
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=300s
          echo "Waiting for LoadBalancer IP to be assigned..."
          sleep 30
        else
          echo "nginx-ingress already installed"
          kubectl patch service ingress-nginx-controller -n ingress-nginx \
            -p '{"spec":{"loadBalancerIP":"${{ env.STATIC_IP }}"}}'
        fi

    - name: Install cert-manager
      run: |
        if ! kubectl get namespace cert-manager &> /dev/null; then
          echo "Installing cert-manager..."
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
          kubectl wait --for=condition=Available --timeout=300s deployment/cert-manager -n cert-manager
          kubectl wait --for=condition=Available --timeout=300s deployment/cert-manager-webhook -n cert-manager
          kubectl wait --for=condition=Available --timeout=300s deployment/cert-manager-cainjector -n cert-manager
        else
          echo "cert-manager already installed"
        fi

    # ─── Deploy Application ─────────────────────
    - name: Apply Kubernetes manifests
      run: |
        kubectl apply -f infrastructure/k8s/ephemera/namespace.yaml
        kubectl apply -f infrastructure/k8s/ephemera/configmap.yaml

        # Create secret from Terraform outputs and GitHub secrets
        kubectl create secret generic ephemera-secrets -n ephemera-system \
          --from-literal=DATABASE_URL="${{ env.DATABASE_URL }}" \
          --from-literal=REDIS_URL="${{ env.REDIS_URL }}" \
          --from-literal=CELERY_BROKER_URL="${{ env.REDIS_URL }}" \
          --from-literal=CELERY_RESULT_BACKEND="${{ env.REDIS_URL }}" \
          --from-literal=GITHUB_APP_ID="${{ secrets.APP_ID }}" \
          --from-literal=GITHUB_APP_CLIENTID="${{ secrets.APP_CLIENT_ID }}" \
          --from-literal=GITHUB_WEBHOOK_SECRET="${{ secrets.WEBHOOK_SECRET }}" \
          --from-literal=GITHUB_APP_PRIVATE_KEY="${{ secrets.APP_PRIVATE_KEY }}" \
          --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
          --from-literal=GITHUB_OAUTH_CLIENT_ID="${{ secrets.OAUTH_CLIENT_ID }}" \
          --from-literal=GITHUB_OAUTH_CLIENT_SECRET="${{ secrets.OAUTH_CLIENT_SECRET }}" \
          --from-literal=ENCRYPTION_KEY="${{ secrets.ENCRYPTION_KEY }}" \
          --from-literal=ANTHROPIC_API_KEY="${{ secrets.ANTHROPIC_API_KEY }}" \
          --from-literal=AI_PROVIDER="anthropic" \
          --dry-run=client -o yaml | kubectl apply -f -

        # Apply Let's Encrypt ClusterIssuer
        export LETSENCRYPT_EMAIL="${{ secrets.LETSENCRYPT_EMAIL }}"
        envsubst < infrastructure/k8s/letsencrypt-issuer.yaml.template | kubectl apply -f -

        kubectl apply -f infrastructure/k8s/ephemera/api-deployment.yaml
        kubectl apply -f infrastructure/k8s/ephemera/celery-worker-deployment.yaml
        kubectl apply -f infrastructure/k8s/ephemera/celery-beat-deployment.yaml
        kubectl apply -f infrastructure/k8s/ephemera/api-service.yaml
        kubectl apply -f infrastructure/k8s/ephemera/api-ingress.yaml

    - name: Run database migrations
      run: |
        # Wait for pods to be ready before running migrations
        kubectl wait --for=condition=ready pod -l component=api -n ephemera-system --timeout=120s || true
        kubectl exec -n ephemera-system deployment/ephemera-api -- alembic upgrade head || echo "Migration failed or no pods running yet"

    - name: Update deployment images
      run: |
        kubectl set image deployment/ephemera-api api=${{ env.ARTIFACT_REGISTRY }}/ephemera-api:${{ github.sha }} -n ephemera-system
        kubectl set image deployment/ephemera-celery-worker celery-worker=${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-worker:${{ github.sha }} -n ephemera-system
        kubectl set image deployment/ephemera-celery-beat celery-beat=${{ env.ARTIFACT_REGISTRY }}/ephemera-celery-beat:${{ github.sha }} -n ephemera-system

    - name: Wait for rollout to complete
      run: |
        kubectl rollout status deployment/ephemera-api -n ephemera-system --timeout=5m || {
          echo "Rollout failed! Checking pod status and logs..."
          kubectl get pods -n ephemera-system
          kubectl describe pods -n ephemera-system -l component=api
          echo "=== Recent logs from failing pods ==="
          kubectl logs -n ephemera-system -l component=api --tail=50 --all-containers=true || true
          exit 1
        }
        kubectl rollout status deployment/ephemera-celery-worker -n ephemera-system --timeout=5m
        kubectl rollout status deployment/ephemera-celery-beat -n ephemera-system --timeout=5m

    - name: Verify deployment
      run: |
        kubectl get pods -n ephemera-system
        kubectl get ingress -n ephemera-system
        INGRESS_IP=$(kubectl get ingress ephemera-api -n ephemera-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Deployment complete!"
        echo "API accessible at: https://ephemera-api.devpreview.app"
        echo "Ingress IP: ${INGRESS_IP}"
        echo "Make sure Cloudflare DNS points to: ${INGRESS_IP}"
